import java.util.ArrayList;
import java.util.List;

/**
 * This class implements StringSearchInterface.
 *
 * @author Jesse Chen
 */
public class StringSearch implements StringSearchInterface {
	
	private int NTH_BASE;

	/**
	 * Boyer Moore algorithm that relies on last table. Make sure to implement
	 * the table before implementing this method. Works better with large
	 * alphabets.
	 *
	 * @param needle a string you a searching for in a body of text
	 * @param haystack the body of text where you search for needle
	 * @return list of integers representing the first index a match occurs
	 */
	public List<Integer> boyerMoore(String needle, String haystack) {
		if (needle == null || haystack == null) {
			throw new IllegalArgumentException();
		} else if (needle.length() > haystack.length()) {
			return new ArrayList<Integer>();
		}
		
		int[] table = buildLastTable(needle);
		int skip = 0;
		List<Integer> result = new ArrayList<Integer>();
		
		for (int i = 0; i < haystack.length() - needle.length() + 1; i += skip) {
			int curr = i + needle.length() - 1;
			boolean mismatch = false;
			
			for (int j = needle.length() - 1, k = 0; j > -1 && !mismatch; j--, k++) {
				if (haystack.charAt(curr) != needle.charAt(j)) {
					mismatch = true;
					
					skip = Math.max(1, table[Character.valueOf(haystack.charAt(curr))] - k);
				} else {
					curr--;
				}
			}
			
			if (!mismatch) {
				result.add(i);
				skip = 1;
			}
		}
		
		return result;
	}

	/**
	 * Builds last table that can be used to run the Boyer Moore algorithm.
	 * The formula for computing a given entry of the last table is:
	 *
	 *		max(needle.length - needle.lastIndexOf(c) - 1, 1)
	 *
	 * where c is a particular character in your needle.
	 *
	 * HINT: Characters auto cast to their corresponding int in ASCII
	 *
	 * @param needle a string you are building last table for
	 * @return integer array of size (Character.MAX_VALUE + 1) containing the mapping
	 *		   for all characters in the alphabet
	 */
	public int[] buildLastTable(String needle) {
		if (needle == null) {
			throw new IllegalArgumentException();
		}

		int[] map = new int[Character.MAX_VALUE + 1];
		
		for (int i = 0; i < map.length; i++) {
			map[i] = needle.length();
		}
		for (int i = 0; i < needle.length(); i++) {
			map[needle.charAt(i)] = Math.max(needle.length() - needle.lastIndexOf(needle.charAt(i)) - 1, 1);
		}
		
		return map;
	}

	/**
	 * Hash function used for Rabin-Karp. The formula for hashing a string is:
	 *
	 *		sum of: c * BASE ^ (needle.length - 1 - i), where c is the integer
	 *		value of the current character, and i is the index of the character
	 *
	 * For example: Hashing "bunn" as a substring of "bunny" with base 433 hash
	 * = b * 433 ^ 3 + u * 433 ^ 2 + n * 433 ^ 1 + n * 433 ^ 0 = 98 * 433 ^ 3 +
	 * 117 * 433 ^ 2 + 110 * 433 ^ 1 + 110 * 433 ^ 0 = 7977892179
	 *
	 * @param current substring you are generating hash function for
	 */
	public int generateHash(String current) {
		if (current == null) {
			throw new IllegalArgumentException();
		}

		NTH_BASE = pow(BASE, current.length() - 1);
	 	int hash = 0;
		for (int i = 0; i < current.length(); i++) {
			char x = current.charAt(i);
			hash += pow(BASE, current.length() - 1 -i) * x;
		}
		
		return hash;
	}
	
	/**
	 * Private helper power method.
	 * 
	 * @param base the base
	 * @param exp the exponent
	 * @return the value of base raised to the power of exp.
	 */
	private int pow(int base, int exp) {
		int val = 1;
		
		for (int i = exp; i > 0; i--) {
			val *= base;
		}
		
		return val;
	}

	/**
	  * Updates a hash in constant time to avoid constantly recalculating
	  * entire hash. To update the hash:
	  *
	  * 	remove the oldChar times BASE raised to the length -
	  * 	1, multiply by BASE, and add the newChar
	  *
	  * For example: Shifting from "bunn" to "unny" in "bunny" with base 433
	  * hash("unny") = (hash("bunn") - b * 433 ^ 3) * 433 + y * 433 ^ 0 =
	  * (7977892179 - 98 * 433 ^ 3) * 433 + 121 * 433 ^ 0 = 9519051770
	  *
	  * @param oldHash hash generated by generateHash
	  * @param length length of needle/substring of haystack
	  * @param oldChar character we want to remove from hashed substring
	  * @param newChar character we want to add to hashed substring
	  */
	public int updateHash(int oldHash, int length, char oldChar, char newChar) {
		//don't use length
		return (oldHash - (oldChar * NTH_BASE)) * BASE + newChar;
	}

	/**
	   * Runs Rabin-Karp algorithm. Generate initial hash, and compare it with
	   * hash from substring of haystack same length as needle. If the two
	   * hashes match compare their individual characters, else update hash
	   * and continue.
	   *
	   * @param needle a string you a searching for in a body of text
	   * @param haystack the body of text where you search for needle
	   * @return list of integers representing the first index a match occurs
	   */
	public List<Integer> rabinKarp(String needle, String haystack) {
		if (needle == null || haystack == null) {
			throw new IllegalArgumentException();
		} else if (needle.length() > haystack.length()) {
			return new ArrayList<Integer>();
		}
		
		int hash = generateHash(needle);
		String substring = haystack.substring(0, needle.length());
		int prev = generateHash(substring);
		List<Integer> result = new ArrayList<Integer>();
		
		if (prev == hash && needle.equals(substring)) {
			result.add(0);
		}
		
		for (int i = 1; i < haystack.length() - needle.length() + 1; i++) {
			substring = haystack.substring(i, i + needle.length());
			prev = updateHash(prev, 0, haystack.charAt(i - 1), haystack.charAt(i + needle.length() - 1));
			
			if (prev == hash && needle.equals(substring)) {
				result.add(i);
			}
		}
		
		return result;
	}
}